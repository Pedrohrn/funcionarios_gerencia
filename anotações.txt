--- Usuários poderão ter cadastro livre (sem vínculo com grupos ou cargos)?:
			-> não, no ato do cadstro do usuário, será necessário e obrigatório escolher um grupo no qual ele fará parte (selecione ou cadastre um grupo);
			-> sim:
				-> grupo 'constante' "Sem grupos", nos quais os usuários sem vínculos serão colocados;
				-> deixar soltos na tela, abaixo de todos os grupos;
--- Usuários terão a base de cadastro do próprio sistema (igual ao cadastro feito na tela de permissões) ou será uma tabela diferente?
--- Tela de gerenciamento de cargos (edição, exclusão, etc)?
--- Tela de gerenciamento de grupos (edição, exclusão, etc)?
--- A filtragem na tela principal é por grupo ou por usuário (listagem de grupos, com seus usuários; ou uma listagem de usuários aglomerados, que irão gerar o grupo)?

Trocar componente cargo/função "editar/adicionar/excluir"
quebrar tela de cadastro de grupo (permissoes vai para tela de cadastro de usuario, numa nova seção, e grupo vai para topbar ctrl, com direito à drag and drop); colocar select de grupo



tel_list = []

100.times do
t = Faker::PhoneNumber.phone_number
telList << telefone
end

def sort_numero
q = [1,2,3,4]
q.sample
end

10.times do
u = Usuario.new(nome: Faker::Name.name, email: Faker::Internet.email, cpf: CpfUtils.cpf, rg: Faker::Number.number(7), cargo_id: Faker::Number.within(1..5), grupo_id: Faker::Number.within(1..4), vigencia_inicio: Faker::Date.between(5.years.ago, Date.today), vigencia_fim: Faker::Date.between(5.years.ago, Date.today), cep: Faker::Address.zip, logradouro: Faker::Address.street_name, cidade: Faker::Address.city, bairro: Faker::Address.community, complemento: Faker::Address.secondary_address, data_nascimento: Faker::Date.between(60.years.ago, Date.today), telefones: telList.sample(sort_numero))
u.save
end


talvez será necessário criar a tabela de férias [ :inicio, :fim, :observacoes, :user_id ] (com user_id)


Usuario
	id
	grupo_id
	cargo_id
	inativado_em
	foto
	nome
	...
	DADOS PESSOAIS
	...
	vigencia =
		{ data_inicio, data_fim }
	expedientes = [
		{ days_list }
	]
	anexos
	grupo_permissoes = [
		{ grupo_id }
	]
	gestoes = [
		{ gestao_id }
	]
	ferias = [
		{ data_inicio, data_fim, observacoes }




TODO
	-> edição de grupos (usuarios) e categorias (passagem_serviço) tá zuada. ao editar mais de um ao mesmo tempo, o controller buga, pegando uma só informação e colocando nos outros três campos
	-> é possível os cards ficarem alinhados, mesmo quando não são do mesmo tamanho?
	-> olhar a tela de resumo para tentar aplicar a dinâmica dos cards na show dos usuarios (desafio: fazer com que a ação de arrastar um usuario troque o seu grupo)


	-> quais dados serão necessários para salvar um usuário?
		usuario:
		{
			nome,
			cpf,
		}


CorpoDiretivo


STI

Cliente::Pessoa.all.first
	# type
	Administrativo::Pesssoa < Cliente::Pesssoa
		type = 'Administrativo::Pesssoa'

		Administravio::VinculoUnidadeMorador < Administrativo::Pesssoa
			type = 'Administrativo::VinculoUnidadeMorador'

		Administravio::VinculoUnidadeFuncionario < Administrativo::Pesssoa
			type = 'Administrativo::VinculoUnidadeFuncionario'


	Financeiro::Pesssoa
	xxx::Pessoa




	Administrativo::FuncionarioGrupo
		has_many :funcionarios, class_name: 'Administrativo::Funcionario'
			belongs_to :cargo, class_name: 'Administrativo::FuncionarioCargo'
			belongs_to :pessoa, class_name: 'Administrativo::Pesssoa'


Tela assumirá a ordenação parecendo com a tela de moradores.
Adicionar usuário, no top_bar_content dará lugar ao adicionar grupo. para adciionar usuário, é somente dentro do grupo agora (como se fosse em moradores). tendo isso em vista, moral de grupos pode morrer
aplicar as nomenclaturas dos modelos conforme acima.
separar os itens da tela de cadastro (form). o que diz respeito ao funcionário ficará no top, e os demais dados (dados gerais, pessoais) ficarão abaixo, isolados.

